(defpackage #:alg-11
 (:use :cl))

(in-package #:alg-11)

;;;; 11 散列表

; 在最坏的情况下，散列表hash table查找一个元素的时间与链表相同，达到O(n)
; 然而在实际应用中它的性能是极好的，在一个合理的假设下，在散列表中查找一个元素的平均时间是O(1)

;;;; 11.1 直接寻址表(direct-address table)

; 当关键字的全域U比较小时，直接寻址是一种简单有效的技术
; 我们用一个数组表示直接寻址表T[0...n]，它的操作实现如下：
; DIRECT-ADDRESS-SEARCH(T, k)
; 	return T[k]
; 
; DIRECT-ADDRESS-INSERT(T, x)
; 	T[x.key] = x
; 
; DIRECT-ADDRESS-DELETE(T, x)
; 	T[x.key] = nil
; 
; 上述每个操作，只需要O(1)的时间
; 直接寻址技术缺点也很明显，如果全域U很大，这需要很大的容量

;;;; 11.2 散列表

; 当存储在字典的关键字集合K比所有可能的关键字的全域U要小许多时，散列表需要的存储空间比直接寻址表少得多
; 此时，可以利用散列函数(hash function)，重新计算映射关键字k的地址，缩小了地址范围(存储空间)

; 运用散列函数时会存在一个问题：两个关键字可能会映射到同一个地址值，这种情况称为“冲突”(collision)
; 下面介绍一种最简单的冲突解决方法，称为“链接法”(chaining)

;;; 链接法
; 链接法，就是把散列到同一地址的所有元素都放在一个链表中，这个地址指向所有散列到它的链表的表头
; 如果不存在这样的散列值，则为NIL

; 伪代码实现：
; CHAINED-HASH-INSERT(T, x)
;     insert x at the head of list T[h(x.key)]
; 
; CHAINED-HASH-SEARCH(T, x)
;     search for an element with key k in list T[h(k)]
; 
; CHAINED-HASH-DELETE(T, x)
;     delete x from the list T[h(x.key)]


; 链接法性能分析

; 最坏情况：所有关键字都散列到同一个地址槽，这样就产生一个长度n为关键字个数的链表，这时最坏的时间查找为O(n)
; 在加上计算散列的时间，就和一个链表链接所有元素差不多

; 散列方法的平均性能依赖于所选取的散列函数h，将所有关键字集合分布在地址槽上的均匀程度

;;;; 11.3 散列函数

; 好的散列函数(近似的)满足简单均匀散列假设：
; 每个关键字都被等可能地散列到m个地址槽位中的任何一个，并与其他关键字已经散列到哪个槽位无关
; 遗憾的是，无法检测这一条件是否成立，因为很少能知道关键字散列所满足的概率分布
; 而且关键字可能并不完全独立的

; 下面散列函数设计方法中，假定关键字都被以某种方式转换成自然数

;;;;; 11.3.1 除法散列法

; 通过取k除以m的余数，将关键字k映射到m个槽位中的某一个上
; 即散列函数为：h(k) = k mod m
; 除法散列法对m的选择比较关键

;;;;; 11.3.2 乘法散列法

; 构造散列函数的乘法散列法包含两个步骤：
; 一：用关键字k乘上常数A(0 < A < 1)，并提取kA的小数部分
; 二：用m乘以这个值，在向下取整
; 最终，散列函数为：h(k) = |_ m(kA mod 1) _|
;
; 乘法散列法的一个优点是对m的选择不是特别关键

;;;;; 11.3.3 全域散列法

; 利用随机技术来提供可证明的良好性能

; 任何一个特定的散列函数都可能出现这种情况：
; 使其n个关键字全部散列到同一个槽位中，使得平均的检索时间为O(n)
; 全域散列就是随机地选择散列函数，使之独立于要存储的关键字

; 全域散列法在执行开始时，就从一组精心设计的函数中，随机地选择一个作为散列函数
; 因为随机选择散列函数，算法在每一次执行时都会有所不同，甚至对于相同的输入都会如此
; 
; 设H为一组有限散列函数，它将给定的关键字全域U映射到{0, 1, ... , m - 1}
; 这样的一个函数组称为全域的(universal)，
; 如果从H中随机地选择一个散列函数，当关键字a != b时，两者发生冲突的概率不大于1/m
; 这也正好是从集合{0, 1, ... , m - 1}中独立地随机选择h(a)和h(b)时发生冲突的概率

;;;; 11.4 开放寻址法(open addressing)

; 开放寻址法是用于解决散列冲突
; 在开放寻址中，所有的元素都存放在散列表中，也就是说，每个散列表项，
; 包含关键字动态集合的一个元素或者nil，散列表可能会被填满，
; 所以开放寻址法的装载因子(动态元素集合/散列表)绝对不会超过1
; 
; 开放寻址法的相比链接法的好处是不用指针，而是计算要存取的槽序列，
; 不用指针而节省的空间，使得可以用同样的空间来提供更多的槽，
; 潜在的减少冲突，提高了检索速度(此处是以空间大小为准)

; 为了使用开放寻址法插入一个元素，需要连续地检查散列表，或称为“探查”(probe)，
; 直到找到一个空槽来放置待插入的关键字为止，检查不一定是顺序查找，
; 而是要依赖于待插入的关键字，为了确定需要探查哪些槽，我们扩充下散列函数，
; 使之包含探查号(从0开始)以作为第二个输入参数，对于每一个关键字k，
; 使用开放寻址法的“探查序列”(probe sequence):<h(k, 0), h(k, 1), ... ,h(k, m - 1)>是<0,1...,m-1>的一个排列，
; 使得当散列表逐渐填满时，每一个表位最终都可以被考虑为用来插入新关键字的槽，
; 
; 伪代码表示：
; hash-insert (T, k)
;     i = 0
;     repeat
;         j = h(k, i) //依赖散列函数的具体实现
; 	if T[j] == NIL
; 	    T[j] = k
; 	    return j
; 	else
; 	    i = i + 1
;     until i == m
;         error "hash table overflow"    
; 
; hash-search (T, k)
;     i = 0
;     repeat
;         j = h(k, i)
;         if T[j] == k
;             return j
;         i = i + 1
;     until T[j] == NIL or i == m
;     return NIL    
; 
; 从开放寻址法的散列表中删除操作元素比较困难，所以，在必须删除关键字的应用中，更常用的做法是采用链接法来解决冲突

; 三种计算开放寻址法中的探查序列：线性探查，二次探查，双重探查

; ... TODO

;;;; 11.5 完全散列

; 当关键字集合是静态(指一旦各关键字存入表中，关键字集合就不再变化)，
; 用“完全散列”(perfect hashing)进行查找时，能在最坏的情况下用O(1)次访问完成
; 
; 可以采用两级的散列方法来设计完全散列方案，在每级上都使用全域散列


;;;; 小结
; 解决散列冲突的主要基本方法：链接法，开放地址法







